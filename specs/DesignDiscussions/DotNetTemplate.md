# Overview
## Templating
![](img1.png)

Template allows users to define where data binding occurs.

```json
{
    "type": "TextBlock",
    "text": "{latestPrice} ",
    "size": "ExtraLarge"
}
```

Once binding is defined, adaptive cards will be updated by changing only the data.
```json
{
  "latestPrice": 128.9,
}
```
### Syntax
- Binding syntax starts with { and ends with }. E.g., {myProperty}
- Dot-notation to access sub-objects
 - {employee.manager.name}
- Indexer syntax to retrieve properties by key or items in an array
 - {employee.peers[0].name}
- $data assigns data context to current element
- $when conditional expression that determiens if current element to be included.
- functions are provided to help SDK users

# Parsing
- We use ANTLR to generate parser and lexer

## ANTLR
From a grammar, ANTLR generates a parser that can build parse trees and also generates a listener interface (or visitor) that makes it easy to respond to the recognition of phrases of interest.
ANTLR is really two things: a tool that translates your grammar to a parser/lexer in Java (or other target language) and the runtime needed by the generated parsers/lexers.
Once parsers and lexers are generated, the tool is no longer needed, so it won't be part of template SDK. CEL uses ANTLR, so CEL SDK already includes ANTRL runtime. There will be no additional penaly of using ANTLR with careful planning

## Parsing Strategy
Current grammar is based on standard json grammar with the addtional rules to handle adaptive card template language
```json
{
	"$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
	"type": "AdaptiveCard",
	"version": "1.0",
	"body": [
		{
			"type": "TextBlock",
			"text": "**wrap: true** Lorem ipsum dolor sit amet",
			"wrap": true
		}
	]
}
```
The above json will be parsed into a parse tree by the parser.  
ANTLR also provides a walker that takes a visitor as an argument. As the walker walks the tree, visitor's visit methods are called. Visit methods are defined per new grammar by default

```
pair
   : StringDeclOpen STRING CLOSE COLON value    # jsonPair
   | StringDeclOpen TEMPLKEYWRD CLOSE COLON value # templateData
   ;
```

From this grammar snippet, the parser generation tool will create a pairVisit method to a base visitor we have to implement. By overriding this method, when walker visit the pair node, it calls the visit method of the node. We can do our own work such as translation in the visit method.

![](antlr4_parse_tree_1.png)

**Parse Tree with Templated String**
```json
{
	"$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
	"type": "AdaptiveCard",
	"version": "1.0",
	"body": [
		{
			"type": "TextBlock",
			"text": "**wrap: true** {content}",
			"wrap": true
		}
	]
}
```

Notice that templateString node has been added, likewise other template keywords such as $data, $when, $root, $index, and etc can be parsed by the generated parser and lexer
parser and lexer can be used on other platforms since they are generated by ANTLR tool. Visitor and Return Objects are needed to be implemented on other platforms
![](antlr4_parse_tree_2.png)

## Adaptive Expression Language
This was initially intended to provide us functions supports. It already supports many functions such as toLower, toString, equals, add, div, and [etc](https://github.com/microsoft/BotBuilder-Samples/blob/master/experimental/common-expression-language/prebuilt-functions.md)  
But the AEL can do more. It can evaluate our templated string as well.

```dotnet
private ExpressionEngine _expressionEngine = new ExpressionEngine();
/// some lines of code later
var result = _expressionEngine.Parse(unboundString).TryEvaluate(data);
```

Signature of TryEvaluate
```dotnet
/// <summary>
/// Evaluate the expression.
/// </summary>
/// <param name="state">
/// Global state to evaluate accessor expressions against.  Can be <see cref="IDictionary{String}{Object}"/>, <see cref="IDictionary"/> otherwise reflection is used to access property and then indexer.
/// </param>
/// <returns>Computed value and an error string.  If the string is non-null, then there was an evaluation error.</returns>
public (object value, string error) TryEvaluate(object state)
```
We just need to ensure our data implement IDictionary interface to be able to use this API for templated string expansion purposes.

## Data Context
- Data context is a data object adaptive element can use
- It supports memory concept of scope
- It has two types, dictionary and array

#### Scope
Data objects can be placed anywhere in AdaptiveCards elements such as Container, TextBlock, and etc in json.
Templating string is bound to the nearest data when AdaptiveCard is viewed as a tree

```json
{
    "type": "AdaptiveCard",
    "$data": {
        "key": "1.2"
    },
    "body": [
        {
            "type": "Container",
            "$data": {
                "key": "2"
            },
            "items": [
                {
                    "type": "TextBlock",
                    "$data": {
                        "key": "3"
                    },
                    "text": "key should be 3, actual:{key}",
                    "size": "Medium",
                    "wrap": true
                },
                {
                    "type": "TextBlock",
                    "text": "key should be 2, actual:{key}",
                    "size": "Medium",
                    "wrap": true
                }
            ],
            "style": "good",
            "bleed": true
        }
    ],
    "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
    "version": "{key}"
}
```

The above json will be parsed as below image. First TextBlock will have "3", and the next "2"

![](antlr4_parse_tree_3.png)

global look up table for data objects
key is path to data 
value json object
type bool arary type? YES or NO

## Result Type
string = ((expanded string)? (non-expanded string)?)*; 
templated-strings =  list of paths to data + properties
first elem in the list is path to data
each subsequent element is property

## Post Translation
append all string, once result is returned from the root node
## Data Source

### Types

### Catergory by Placement of Data in json
##### inline
Data is provided as part of adaptive cards
```json
{
    "type": "AdaptiveCard",
    "$data": {
        "employee": {
            "name": "Matt"
        }
    },
    "body": [
        {
            "type": "TextBlock",
            "text": "Hi {employee.name}! Here's a bit about your org..."
        }
    ]
}
```

##### reference
Data is provided as a separate json, and is provided to a parser as a parsing context.

```json
var dataContext = new ACData.EvaluationContext();
dataContext.$root = {
    "employee": {
        "name": "Matt"
    }
};

```json
{
    "type": "AdaptivCard",
    "body": [
        {
            "type": "TextBlock",
            "text": "Hi {employee.name}! Here's a bit about your org..."
        }
    ]
}
```

### Catergory by Accessor Type 
##### property 
Data is accessed via '.' 
```json
{
    "type": "AdaptiveCard",
    "body": [
        {
            "type": "TextBlock",
            "text": "Hi {employee.name}! Here's a bit about your org..."
        }
    ]
}
```

##### array 
Data is accessed via '[]' with index 

```json
{
    "type": "AdaptivCard",
    "body": [
        {
            "type": "TextBlock",
            "text": "3 of your peers are: {employee.peers[0].name}, {employee.peers[1].name}, {employee.peers[2].name}"
        }
    ]
}
```


## Parsing value of $data key entry
As the visitor visits the nodes in a Parse tree.
Data object is parsed to JSON object.
The object is kept in a Trie.
The prefix used for matching is Adaptive Element's Type string.
This works for both DFS and BFS since it's tree siblings share a parent
When templated string is encountered, the trie is used to find the entry that matches the most prefix

should we try to find the best match even when there is no matches in the nearest data object?
how de we handle in repeating context
texts in array, but some properties of the text block's data object is arrary, which array of data to follow?
need example


```json
{
    "{<property>}": "Implicitly binds to `$data.<property>`",
    "$data": "The current data object",
    "$root": "The root data object. Useful when iterating to escape to parent object",
    "$index": "The current index when iterating",
    "$host": "Access properties of the host *(not working yet)*"
}
```
#### Binding
## binds to all templated string when condition is satified
list of allowed attributes to be bound


### Parsing Strategy For each catergories 
