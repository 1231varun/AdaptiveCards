# Overview
## Templating
![](img1.png)

Template allows users to define where data binding occurs.

```json
{
    "type": "TextBlock",
    "text": "{latestPrice} ",
    "size": "ExtraLarge"
}
```

Once binding is defined, adaptive cards will be updated by changing only the data.
```json
{
  "latestPrice": 128.9,
}
```
### Syntax
- Binding syntax starts with { and ends with }. E.g., {myProperty}
- Dot-notation to access sub-objects
 - {employee.manager.name}
- Indexer syntax to retrieve properties by key or items in an array
 - {employee.peers[0].name}
- $data assigns data context to current element
- $when conditional expression that determines if current element to be included.
- functions are provided to help SDK users

# Parsing
- We use ANTLR to generate parser and lexer

## ANTLR
From a grammar, ANTLR generates a parser that can build parse trees and also generates a listener interface (or visitor) that makes it easy to respond to the recognition of phrases of interest.
ANTLR is really two things: a tool that translates your grammar to a parser/lexer in Java (or other target language) and the runtime needed by the generated parsers/lexers.
Once parsers and lexers are generated, the tool is no longer needed, so it won't be part of template SDK. CEL uses ANTLR, so CEL SDK already includes ANTRL runtime. There will be no additional penaly of using ANTLR with careful planning

## Parsing Strategy
Current grammar is based on standard json grammar with the addtional rules to handle adaptive card template language
```json
{
	"$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
	"type": "AdaptiveCard",
	"version": "1.0",
	"body": [
		{
			"type": "TextBlock",
			"text": "**wrap: true** Lorem ipsum dolor sit amet",
			"wrap": true
		}
	]
}
```
The above json will be parsed into a parse tree by the parser.  
ANTLR also provides a walker that takes a visitor as an argument. As the walker walks the tree, visitor's visit methods are called. Visit methods are defined per new grammar by default.
When a visitor method is called, it will be called with a context. The context will be a data structure representing the current visiting node.

```
pair
   : StringDeclOpen STRING CLOSE COLON value    # jsonPair
   | StringDeclOpen TEMPLKEYWRD CLOSE COLON value # templateData
   ;
```

From this grammar snippet, the parser generation tool will create a pairVisit method to a base visitor we have to implement. By overriding this method, when walker visit the pair node, it calls the visit method of the node. We can do our own work such as translation in the visit method.

**Figure 2**
![](antlr4_parse_tree_1.png)

**Parse Tree with Templated String**
```json
{
	"$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
	"type": "AdaptiveCard",
	"version": "1.0",
	"body": [
		{
			"type": "TextBlock",
			"text": "**wrap: true** {content}",
			"wrap": true
		}
	]
}
```

Notice that templateString node has been added, likewise other template keywords such as $data, $when, $root, $index can be parsed by the generated parser and lexer  
Parser and lexer can be used on other platforms since they are generated by ANTLR tool and can be targeted to different languages. Visitor and Return Objects are needed to be implemented on other platforms.  
  
**Figure 3**
![](antlr4_parse_tree_2.png)

## Adaptive Expression Language
This was initially intended to provide us functions support. AEL already has many built-in functions such as toLower, toString, equals, add, div, and [etc](https://github.com/microsoft/BotBuilder-Samples/blob/master/experimental/common-expression-language/prebuilt-functions.md)  
But the AEL can do more. It can evaluate our templated string as well.

```dotnet
private ExpressionEngine _expressionEngine = new ExpressionEngine();
/// some lines of code later
var result = _expressionEngine.Parse(unboundString).TryEvaluate(data);
```

**Signature of TryEvaluate**
```dotnet
/// <summary>
/// Evaluate the expression.
/// </summary>
/// <param name="state">
/// Global state to evaluate accessor expressions against.  Can be <see cref="IDictionary{String}{Object}"/>, <see cref="IDictionary"/> otherwise reflection is used to access property and then indexer.
/// </param>
/// <returns>Computed value and an error string.  If the string is non-null, then there was an evaluation error.</returns>
public (object value, string error) TryEvaluate(object state)
```
We just need to ensure our data implement IDictionary interface to be able to use this API for templated string expansion purposes.

## Data Context
- Data context is a data object adaptive element can use
- Data context supports a memory concept, scope
- Data context has two types, dictionary and array

#### Scope
Data objects can be placed anywhere in AdaptiveCards elements such as Container, TextBlock, and etc in json.
Templating string is bound to the nearest data when AdaptiveCard is viewed as a tree

```json
{
    "type": "AdaptiveCard",
    "$data": {
        "key": "1.2"
    },
    "body": [
        {
            "type": "Container",
            "$data": {
                "key": "2"
            },
            "items": [
                {
                    "type": "TextBlock",
                    "$data": {
                        "key": "3"
                    },
                    "text": "key should be 3, actual:{key}",
                    "size": "Medium",
                    "wrap": true
                },
                {
                    "type": "TextBlock",
                    "text": "key should be 2, actual:{key}",
                    "size": "Medium",
                    "wrap": true
                }
            ],
            "style": "good",
            "bleed": true
        }
    ],
    "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
    "version": "{key}"
}
```

The above json will be parsed as below image. First TextBlock will have "3", and the next "2"  
  
**Figure 4**
![](antlr4_parse_tree_3.png)

We also have **$root** key word. This is the data context at the root level meaning it will be set at AdaptiveCard level, and applies to all element with all the scoping rule respected as discussed

### Type
Data can be either dictionary type or array type

```json
"$data": 
    { "name": "Matt" },
```

```json
"$data": [
    { "name": "Matt" },
    { "name": "David" },
    { "name": "Thomas" }
],
```
### Parsing Strategy
Since introduction of a new data context happens only in a pair and only an obj can include the pair, the Obj is the natural place to handle the data context. 
In VisitObj method, it filters through the method's current context's children which are pairs, and tries to catch a data context node. 
(*Do we use first one we see, or do we have to see all of them?*) Current design tentatively uses the first one it sees for the performance reason.  
When a data context node is encountered, it call a base visit method with the node, then the method resolved into VisitTemplateData method.
The method, creates a data context object with a field that indicates Array if set. The data context object parse the value in the pair of the data context node into JArray object if it's array, otherwise into JObject
The newly created data context object is set to current context. In current design, it uses a stack for this purpose. When the method returns to the VisitObj method, data context is set, and translation can continue. Please refer to **Figure 4**

## Translation
### Expansion in Basic Form
This is the most basic form of expansion that involves templated string and dictionary type data context 
##### property 
Data is accessed via '.' 
```json
{
    "type": "AdaptiveCard",
    "body": [
        {
            "type": "TextBlock",
            "text": "Hi {employee.name}! Here's a bit about your org..."
        }
    ]
}
```

##### array 
Data is accessed via '[]' with index 

```json
{
    "type": "AdaptivCard",
    "body": [
        {
            "type": "TextBlock",
            "text": "3 of your peers are: {employee.peers[0].name}, {employee.peers[1].name}, {employee.peers[2].name}"
        }
    ]
}
```
The distinction in accessors type was important before the use of AEL. It's not important anymore since the job of expansion is delegated to AEL.
### Parsing Strategy
Terminal Nodes or leaf nodes contain the templated string, so the default VisitTerminal method is overridden. When the method sees that given parse context is a TEMPLATELITERAL, it tries to expand using AEL & given data context. Since our data context is JToken type which implements IDictionary, AEL can expand it. When expansion fails, the method indicate that the literal has been expanded, so when the result is returned, the unaltered literal will be included in the result     

### Expansion with Array Data Context                                                                                                                         
When data context type is an array, there is an adaptive element that uses the data context. Template lagunage specifies that the adaptive element that hosts the data context repeats the subtree that has itself the root node.  

```json
{
    "type": "AdaptiveCard",
    "version": "1.0",
    "body": [
        {
            "type": "Container",
            "items": [
                {
                    "type": "TextBlock",
                    "text": "Header"
                },
                {
                    "$data": [
                        {
                            "name": "Star",
                            "nickname": "Dust"
                        },
                        {
                            "name": "Death",
                            "nickname": "Star"
                        }
                    ],
                    "type": "FactSet",
                    "facts": [
                        {
                            "title": "{name}",
                            "value": "{nickname}"
                        }
                    ]
                }
            ]
        }
    ],
    "$schema": "http://adaptivecards.io/schemas/adaptive-card.json"
}
```
**Figure 5**  
![](arrayType1.png)

```json
{
    "type": "AdaptiveCard",
    "version": "1.0",
    "body": [
        {
            "type": "Container",
            "$data": [
                {
                    "name": "Star",
                    "nickname": "Dust"
                },
                {
                    "name": "Death",
                    "nickname": "Star"
                }
            ],
            "items": [
                {
                    "type": "TextBlock",
                    "text": "Header"
                },
                {
                    "type": "FactSet",
                    "facts": [
                        {
                            "title": "{name}",
                            "value": "{nickname}"
                        }
                    ]
                }
            ]
        }
    ],
    "$schema": "http://adaptivecards.io/schemas/adaptive-card.json"
}
```  
**Figure 6**  
![](arrayType2.png)  

Notice what's being repeated in **Figure 5** & **Figure 6**. In **Figure 5**, the FactSet is repeated since the data context is set at the FactSet. In **Figure 6**, the Container is repeated as the data context is sent at the Container.

### Parsing Strategy
It is obvious from the examples that simply returning the string or StringBuilder is not sufficient. We need ability to delay the expansion until the walker explores all of a subtree where the root has data context and its type is array. And check that one of its child node makes reference to the data context.  

#### Result 
- ANTLR allows Visitor to define a custom return type
- new JSONTemplateVisitorResult  
- It has a linked list inside
- It supports two operations, join and expand
- join is used to merge results returned from other nodes
 - when joining two results if the joint (tail and head) are already expanded, then their nodes are merged to one
 - if they have templated string that needs to be expanded, then they are linked as linked lists 
- In the VisitObj method, once visit to children finishes, we have one merged result object
- if data context object was discovered, and it's array type, expansion happens
 - it expand the result with data context. 
 - it repeats n times where n is number of elements in data context
 - the result is merged and returned from the method.
- if data context object wasn't discovered in this node, simply return the current result without expanding.

## When
* Work in progress 
* Similar concept to Array Type
* basic concept is that result is expanded to have branching point
